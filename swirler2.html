<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Swirler View</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:#111;color:#eee}
  .page{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%}
  .canvasPanel{flex:1;position:relative;border-radius:8px;overflow:hidden;background:#0b0b0b;min-width:640px}
  canvas{display:block;width:100%;height:100%}
  svg.overlay{position:absolute;inset:0;pointer-events:none}
  .ui{width:340px;padding:12px;background:#0f1724;border-radius:8px}
  button,input,select{width:100%;padding:8px;margin-top:8px;border-radius:6px;border:1px solid #223;background:#081826;color:#e6eef8}
  .row{display:flex;gap:8px}
  .small{font-size:13px;color:#9fb7d9;margin-top:8px}
  .dimBox{margin-top:12px;padding:8px;background:#07151b;border-radius:6px;border:1px solid rgba(255,255,255,.02)}
  .dimRow{display:flex;justify-content:space-between;padding:6px 0;font-size:13px;color:#dbeafe;border-bottom:1px dashed rgba(255,255,255,.02)}
</style>
</head>
<body>
  <div class="page">
    <div class="canvasPanel" id="canvasPanel">
      <canvas id="c"></canvas>
      <svg id="svgOverlay" class="overlay"></svg>
    </div>

    <div class="ui">
      <label>Model path</label>
      <input id="modelPath" value="./swirler.gltf" />
      <div class="row">
        <button id="loadBtn">Load model</button>
        <button id="resetBtn">Reset</button>
      </div>

      <label>Background</label>
      <select id="bg">
        <option value="dark">Dark</option>
        <option value="light">Light</option>
      </select>

      <label>Part color</label>
      <input id="colorPicker" type="color" value="#ff8833" />

      <div class="row">
        <button id="applyColor">Apply</button>
        <button id="resetColor">Reset</button>
      </div>

      <label>Auto-rotate</label>
      <div class="row">
        <button id="toggleAuto">Auto: ON</button>
      </div>

      <div class="dimBox">
        <div class="dimRow"><div class="small">Width (X)</div><div id="dx">—</div></div>
        <div class="dimRow"><div class="small">Height (Y)</div><div id="dy">—</div></div>
        <div class="dimRow"><div class="small">Depth (Z)</div><div id="dz">—</div></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Interaction</div>
        <div style="margin-top:8px" class="row">
          <button id="enablePick">Pick: OFF</button>
          <button id="clearPick">Clear</button>
        </div>
        <div style="margin-top:8px" id="measureInfo" class="small">Select two vertices to measure distance</div>
      </div>

      <div class="small" style="margin-top:12px">Hover an area to highlight its edges. Click to pick the nearest vertex from that face. Picks show as orange dots; selected edge highlights in bright orange.</div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
const canvas = document.getElementById('c');
const svg = document.getElementById('svgOverlay');
const loadBtn = document.getElementById('loadBtn');
const resetBtn = document.getElementById('resetBtn');
const modelPathInput = document.getElementById('modelPath');
const bgSelect = document.getElementById('bg');
const colorPicker = document.getElementById('colorPicker');
const applyColorBtn = document.getElementById('applyColor');
const resetColorBtn = document.getElementById('resetColor');
const toggleAutoBtn = document.getElementById('toggleAuto');
const dxEl = document.getElementById('dx'), dyEl = document.getElementById('dy'), dzEl = document.getElementById('dz');
const enablePickBtn = document.getElementById('enablePick');
const clearPickBtn = document.getElementById('clearPick');
const measureInfo = document.getElementById('measureInfo');

let renderer, scene, camera, controls, raycaster;
let modelGroup = null;
let autoRotate = true;
let pickingEnabled = false;
let lastHoveredFace = null; // {mesh, faceIndex, a,b,c}
let edgeHighlightMesh = null;
let vertexMarkers = [];
let picks = []; // THREE.Vector3
let originalMaterials = [];

function initThree(){
  renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  resize();
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.001, 1000);
  camera.position.set(0,0.5,1.8);
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.6);
  dir.position.set(2,3,2);
  scene.add(dir);
  raycaster = new THREE.Raycaster();
  window.addEventListener('resize', resize);
  canvas.addEventListener('mousemove', onPointerMove);
  canvas.addEventListener('click', onClick);
  animate();
}

function resize(){
  const w = canvas.clientWidth || canvas.width || 800;
  const h = canvas.clientHeight || canvas.height || 600;
  renderer.setSize(w,h,false);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  svg.setAttribute('width', w);
  svg.setAttribute('height', h);
}

function animate(){
  requestAnimationFrame(animate);
  if(modelGroup && autoRotate) modelGroup.rotation.y += 0.0025;
  controls.update();
  renderer.render(scene, camera);
}

function clearModel(){
  if(!scene) return;
  if(modelGroup){
    scene.remove(modelGroup);
    modelGroup.traverse(o=>{
      if(o.geometry) o.geometry.dispose();
      if(o.material){
        if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
        else o.material.dispose();
      }
    });
    modelGroup = null;
  }
  clearEdgeHighlight();
  clearVertexMarkers();
  picks = [];
  dxEl.textContent = dyEl.textContent = dzEl.textContent = '—';
}

function loadModel(url){
  clearModel();
  const loader = new THREE.GLTFLoader();
  loader.load(url, gltf=>{
    modelGroup = new THREE.Group();
    // ensure meshes are cast/receive shadow and use MeshStandardMaterial (pbr)
    gltf.scene.traverse(node=>{
      if(node.isMesh){
        node.geometry.computeVertexNormals(); // ensure normals
        node.castShadow = true;
        node.receiveShadow = true;
        // keep original material copies for reset
        if(node.material){
          originalMaterials.push({node, mat: node.material.clone()});
        }
      }
    });
    modelGroup.add(gltf.scene);
    scene.add(modelGroup);
    // center
    const box = new THREE.Box3().setFromObject(modelGroup);
    const size = new THREE.Vector3(); box.getSize(size);
    dxEl.textContent = size.x.toFixed(4);
    dyEl.textContent = size.y.toFixed(4);
    dzEl.textContent = size.z.toFixed(4);
    const center = new THREE.Vector3(); box.getCenter(center);
    modelGroup.position.sub(center);
    fitCamera(size);
  }, xhr=>{}, err=>{
    console.error('load error', err);
    alert('three.js load failed; check console and file path.');
  });
}

function fitCamera(size){
  const maxDim = Math.max(size.x,size.y,size.z);
  const dist = Math.max(1.2, maxDim * 1.6);
  camera.position.set(0, maxDim*0.6, dist);
  controls.target.set(0,0,0);
  controls.update();
}

function onPointerMove(e){
  if(!modelGroup) return;
  const rect = canvas.getBoundingClientRect();
  const mx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  const my = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera({x: mx, y: my}, camera);
  const intersects = raycaster.intersectObject(modelGroup, true);
  if(intersects.length === 0){
    if(lastHoveredFace) { lastHoveredFace = null; clearEdgeHighlight(); }
    return;
  }

  const it = intersects[0];
  const mesh = it.object;
  if(!it.face) return;
  const face = it.face; 
  const geom = mesh.geometry;

  const posAttr = geom.attributes.position;
  const a = new THREE.Vector3().fromBufferAttribute(posAttr, face.a).applyMatrix4(mesh.matrixWorld);
  const b = new THREE.Vector3().fromBufferAttribute(posAttr, face.b).applyMatrix4(mesh.matrixWorld);
  const c = new THREE.Vector3().fromBufferAttribute(posAttr, face.c).applyMatrix4(mesh.matrixWorld);
  // set highlight only if face changed
  const key = mesh.uuid + ':' + it.faceIndex;
  if(!lastHoveredFace || lastHoveredFace.key !== key){
    lastHoveredFace = {mesh, faceIndex: it.faceIndex, a,b,c, key};
    highlightFaceEdges(a,b,c);
  }
}

function highlightFaceEdges(a,b,c){
  clearEdgeHighlight();
  // create geometry for three edges (lines)
  const geom = new THREE.BufferGeometry();
  const pts = new Float32Array([
    a.x,a.y,a.z, b.x,b.y,b.z,
    b.x,b.y,b.z, c.x,c.y,c.z,
    c.x,c.y,c.z, a.x,a.y,a.z
  ]);
  geom.setAttribute('position', new THREE.BufferAttribute(pts, 3));
  const mat = new THREE.LineBasicMaterial({color:0xffa657, linewidth:2});
  edgeHighlightMesh = new THREE.LineSegments(geom, mat);
  edgeHighlightMesh.renderOrder = 999;
  scene.add(edgeHighlightMesh);
}

function clearEdgeHighlight(){
  if(edgeHighlightMesh){ scene.remove(edgeHighlightMesh); edgeHighlightMesh.geometry.dispose(); edgeHighlightMesh.material.dispose(); edgeHighlightMesh = null; }
}

function worldToScreen(v){
  const vec = v.clone().project(camera);
  const x = (vec.x + 1) / 2 * canvas.clientWidth;
  const y = (-vec.y + 1) / 2 * canvas.clientHeight;
  return {x,y};
}

function createSVGDot(x,y){
  const ns = 'http://www.w3.org/2000/svg';
  const c = document.createElementNS(ns,'circle');
  c.setAttribute('cx', x); c.setAttribute('cy', y); c.setAttribute('r',6);
  c.setAttribute('fill','#ffb86b'); c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width',1.2);
  svg.appendChild(c);
  return c;
}

function clearVertexMarkers(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
  vertexMarkers = [];
}

function onClick(e){
  if(!pickingEnabled || !lastHoveredFace) return;
  const rect = canvas.getBoundingClientRect();
  const mousePx = {x: e.clientX - rect.left, y: e.clientY - rect.top};
  const verts = [lastHoveredFace.a, lastHoveredFace.b, lastHoveredFace.c];
  let best = null, bestD = Infinity;
  for(let v of verts){
    const s = worldToScreen(v);
    const d = Math.hypot(s.x - mousePx.x, s.y - mousePx.y);
    if(d < bestD){ bestD = d; best = {v,s}; }
  }
  if(best){
    const dot = createSVGDot(best.s.x, best.s.y);
    vertexMarkers.push({dot, world: best.v.clone()});
    picks.push(best.v.clone());
    if(picks.length === 2) showMeasurement();
    if(picks.length > 2){ picks = [picks[picks.length-1]]; clearSVGDotsExceptLast(); }
  }
}

function clearSVGDotsExceptLast(){
  const last = vertexMarkers[vertexMarkers.length-1];
  clearVertexMarkers();
  if(last){
    const s = worldToScreen(last.world);
    const c = createSVGDot(s.x,s.y);
    vertexMarkers = [{dot:c, world:last.world}];
    picks = [last.world.clone()];
  } else {
    vertexMarkers = [];
    picks = [];
  }
}

function showMeasurement(){
  if(picks.length < 2) return;
  const a = picks[0], b = picks[1];
  const dx = b.x - a.x, dy = b.y - a.y, dz = b.z - a.z;
  const dist = Math.hypot(dx,dy,dz);
  measureInfo.textContent = `Distance: ${dist.toFixed(4)} units (Δx ${dx.toFixed(4)}, Δy ${dy.toFixed(4)}, Δz ${dz.toFixed(4)})`;
  clearEdgeHighlight();
  highlightFaceEdges(a,b,a); 
  const s1 = worldToScreen(a), s2 = worldToScreen(b);
  const ns = 'http://www.w3.org/2000/svg';
  const line = document.createElementNS(ns,'line');
  line.setAttribute('x1', s1.x); line.setAttribute('y1', s1.y); line.setAttribute('x2', s2.x); line.setAttribute('y2', s2.y);
  line.setAttribute('stroke','#ff7a2e'); line.setAttribute('stroke-width','3'); svg.appendChild(line);
  const txt = document.createElementNS(ns,'text');
  txt.setAttribute('x', (s1.x+s2.x)/2 + 8); txt.setAttribute('y', (s1.y+s2.y)/2 - 8);
  txt.setAttribute('fill', '#ffd9b3'); txt.setAttribute('font-size','13'); txt.textContent = dist.toFixed(4);
  svg.appendChild(txt);
}

function clearPickState(){
  clearEdgeHighlight();
  clearVertexMarkers();
  picks = [];
  measureInfo.textContent = 'Select two vertices to measure distance';
}

loadBtn.addEventListener('click', ()=>{
  const url = modelPathInput.value.trim();
  loadModel(url);
});

resetBtn.addEventListener('click', ()=>{
  if(!modelGroup) return;
  controls.reset();
  camera.position.set(0,0.5,1.8);
  controls.update();
  clearPickState();
});

bgSelect.addEventListener('change', ()=>{
  if(bgSelect.value === 'light'){ document.body.style.background = '#e6e6e6'; canvas.style.background = '#d9d9d9'; } else { document.body.style.background = '#111'; canvas.style.background = '#0b0b0b'; }
});

applyColorBtn.addEventListener('click', ()=>{
  if(!modelGroup) return;
  const hex = colorPicker.value;
  const color = new THREE.Color(hex);
  modelGroup.traverse(node=>{
    if(node.isMesh && node.material){
      if(Array.isArray(node.material)) node.material.forEach(m=>{ if(m.color) m.color.copy(color); m.needsUpdate = true; });
      else { if(node.material.color) node.material.color.copy(color); node.material.needsUpdate = true; }
    }
  });
});

resetColorBtn.addEventListener('click', ()=>{
  for(const o of originalMaterials){
    const node = o.node;
    if(node && node.material && o.mat) node.material.copy(o.mat);
  }
  status('colors reset');
});

toggleAutoBtn.addEventListener('click', ()=>{
  autoRotate = !autoRotate;
  toggleAutoBtn.textContent = autoRotate ? 'Auto: ON' : 'Auto: OFF';
});

enablePickBtn.addEventListener('click', ()=>{
  pickingEnabled = !pickingEnabled;
  enablePickBtn.textContent = pickingEnabled ? 'Pick: ON' : 'Pick: OFF';
  if(!pickingEnabled) { clearPickState(); }
});

clearPickBtn.addEventListener('click', clearPickState);

function status(txt){ console.log(txt); }

initThree();

</script>
</body>
</html>