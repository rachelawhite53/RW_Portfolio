<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Swirl — Calculator & Step-by-Step (GPM) — geometry in mm</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], packages: {'[+]': ['ams']} },
    options: { skipHtmlTags: ['script','style','textarea','pre','code'] }
  };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
  :root{
    --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --card: #ffffff;
    --card-hover: #f8fafc;
    --text-primary: #1e293b;
    --text-secondary: #64748b;
    --text-muted: #94a3b8;
    --accent: #0ea5e9;
    --accent-hover: #0284c7;
    --orange: #f97316;
    --orange-light: #fed7aa;
    --blue: #3b82f6;
    --blue-light: #dbeafe;
    --green: #10b981;
    --green-light: #d1fae5;
    --border: #e2e8f0;
    --shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
    --shadow-lg: 0 20px 60px rgba(0, 0, 0, 0.15);
  }
  
  * { box-sizing: border-box; }
  
  body {
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    margin: 0;
    padding: 40px 20px;
    min-height: 100vh;
  }
  
  .wrap {
    max-width: 1100px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 32px;
  }
  
  .card {
    background: var(--card);
    border-radius: 20px;
    padding: 32px;
    box-shadow: var(--shadow);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  .card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  
  h1 {
    margin: 0 0 8px 0;
    font-size: 28px;
    font-weight: 700;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .small {
    font-size: 14px;
    color: var(--text-secondary);
    line-height: 1.6;
  }
  
  .row {
    display: flex;
    gap: 24px;
    margin-top: 24px;
  }
  
  .col {
    flex: 1;
  }
  
  label {
    display: block;
    color: var(--text-primary);
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 10px;
  }
  
  input[type=range] {
    width: 100%;
    height: 8px;
    border-radius: 10px;
    background: linear-gradient(to right, #667eea, #764ba2);
    outline: none;
    -webkit-appearance: none;
  }
  
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    transition: transform 0.2s;
  }
  
  input[type=range]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }
  
  input[type=range]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    border: none;
    transition: transform 0.2s;
  }
  
  input[type=range]::-moz-range-thumb:hover {
    transform: scale(1.2);
  }
  
  input[type=number] {
    width: 100%;
    padding: 12px 16px;
    border-radius: 12px;
    border: 2px solid var(--border);
    font-size: 15px;
    font-weight: 500;
    transition: all 0.2s;
    font-family: 'Inter', sans-serif;
  }
  
  input[type=number]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
  }
  
  .stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-top: 24px;
  }
  
  .stat {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    padding: 20px;
    border-radius: 16px;
    text-align: center;
    border: 2px solid var(--border);
    transition: all 0.3s;
  }
  
  .stat:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
  }
  
  .stat:nth-child(1) { border-color: var(--orange-light); }
  .stat:nth-child(2) { border-color: var(--blue-light); }
  .stat:nth-child(3) { border-color: var(--green-light); }
  
  .stat .num {
    font-weight: 700;
    font-size: 32px;
    margin-top: 8px;
    letter-spacing: -0.5px;
  }
  
  .btn {
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
    color: white;
    padding: 12px 24px;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s;
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
    font-family: 'Inter', sans-serif;
  }
  
  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(14, 165, 233, 0.4);
  }
  
  .btn:active {
    transform: translateY(0);
  }
  
  .btn.green {
    background: linear-gradient(135deg, var(--green) 0%, #059669 100%);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
  }
  
  .btn.green:hover {
    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
  }
  
  a.link {
    color: var(--accent);
    text-decoration: none;
    font-size: 14px;
    font-weight: 600;
    transition: color 0.2s;
  }
  
  a.link:hover {
    color: var(--accent-hover);
    text-decoration: underline;
  }
  
  canvas {
    width: 100% !important;
    height: 240px !important;
    border-radius: 12px;
  }
  
  .muted-note {
    background: #f8fafc;
    border-left: 4px solid var(--accent);
    padding: 16px 20px;
    border-radius: 8px;
    margin-top: 20px;
    font-size: 13px;
    color: var(--text-secondary);
    line-height: 1.6;
  }
  
  .muted-note strong {
    color: var(--text-primary);
  }
  
  .math-notes {
    background: linear-gradient(135deg, #fafbfc 0%, #f8fafc 100%);
    border: 2px solid var(--border);
    padding: 32px;
    border-radius: 16px;
    margin-top: 24px;
  }
  
  .math-notes h3 {
    margin: 0 0 8px 0;
    font-size: 24px;
    font-weight: 700;
    color: var(--text-primary);
  }
  
  .analysis-grid {
    display: grid;
    gap: 20px;
    margin-top: 32px;
  }
  
  .analysis-section {
    background: white;
    border: 2px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s;
  }
  
  .analysis-section:hover {
    border-color: var(--accent);
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.1);
    transform: translateX(4px);
  }
  
  .analysis-section.highlight {
    background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    border-color: var(--blue);
  }
  
  .section-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
  }
  
  .section-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, var(--accent) 0%, var(--blue) 100%);
    color: white;
    border-radius: 8px;
    font-weight: 700;
    font-size: 16px;
    flex-shrink: 0;
  }
  
  .analysis-section h4 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
  }
  
  .analysis-section p {
    margin: 10px 0;
    color: var(--text-secondary);
    line-height: 1.7;
    font-size: 14px;
  }
  
  .math-notes .eq {
    margin: 14px 0;
    padding: 14px 18px;
    border-radius: 10px;
    background: #f8fafc;
    border: 2px solid var(--border);
    overflow-x: auto;
    font-size: 15px;
  }
  
  .key-eq {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important;
    border-color: #f59e0b !important;
    font-weight: 500;
  }
  
  hr {
    border: none;
    border-top: 2px solid var(--border);
    margin: 24px 0;
  }
  
  .input-grid {
    margin-top: 20px;
    display: grid;
    grid-template-columns: 1fr 1fr 220px;
    gap: 24px;
    align-items: start;
  }
  
  .input-group {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  
  .dual-input {
    display: flex;
    gap: 12px;
  }
  
  .dual-input input {
    width: 90px;
  }
  
  .controls {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-top: 20px;
  }
  
  .value-display {
    font-weight: 600;
    color: var(--accent);
    font-size: 15px;
  }
  
  .target-card {
    display: grid;
    gap: 12px;
    grid-template-columns: 1fr;
  }
  
  @media (max-width: 768px) {
    .wrap { padding: 20px 16px; }
    .card { padding: 24px; }
    .row { flex-direction: column; }
    .stats { grid-template-columns: 1fr; }
    .input-grid { grid-template-columns: 1fr; }
    h1 { font-size: 24px; }
  }
</style>
</head>
<body>
  <div class="wrap">

    <div class="card" id="calculatorCard">
      <div>
        <h1>Swirling Jet — Parameter Calculator</h1>
        <div class="small">Adjust axial and tangential flow rates to see $S$ (Swirl Number) and $Re$ (Reynolds Number). Units: GPM (flows) — geometry inputs in <strong>mm</strong>.</div>
      </div>

      <div class="row">
        <div class="col">
          <label for="axial">Axial Flow $Q_{ax}$</label>
          <input id="axial" type="range" min="0" max="200" value="18" step="0.1" />
          <div class="small" style="margin-top:12px">Value: <span id="axialVal" class="value-display">18</span> GPM</div>
        </div>
        <div class="col">
          <label for="tangential">Tangential Flow $Q_{tan}$</label>
          <input id="tangential" type="range" min="0" max="200" value="8" step="0.1" />
          <div class="small" style="margin-top:12px">Value: <span id="tanVal" class="value-display">8</span> GPM</div>
        </div>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="small">Swirl Number (S)</div>
          <div id="S" class="num" style="color:var(--orange)">0.00</div>
        </div>
        <div class="stat">
          <div class="small">Reynolds Number (Re)</div>
          <div id="Re" class="num" style="color:var(--blue)">0</div>
        </div>
        <div class="stat">
          <div class="small">Total Flow</div>
          <div id="Qtot" class="num" style="color:var(--green)">0 GPM</div>
        </div>
      </div>

      <div style="margin-top:28px;">
        <canvas id="barChart"></canvas>
      </div>
    </div>

    <div class="card" id="stepsCard">
      <div>
        <h1>Manual Input — Targets & Geometry</h1>
        <div class="small">Fine-tune inputs or use the values from the calculator. Geometry inputs are required to compute $S$ physically. You can also specify a <strong>target Re</strong> or <strong>target S</strong> and compute the required flow (Q).</div>
      </div>

      <div class="input-grid">
        <div class="input-group">
          <div>
            <label>Axial Flow (GPM)</label>
            <input id="qax" type="number" value="15" step="0.1" />
          </div>
          <div>
            <label>Tangential Flow (GPM)</label>
            <input id="qtan" type="number" value="10" step="0.1" />
          </div>

          <div style="margin-top:8px" class="muted-note">
            <strong>Tip:</strong> Use the sliders above for quick adjustments. Use the target controls (to the right) to compute flows from a desired Re or S.
          </div>
        </div>

        <div class="input-group">
          <div>
            <label>Nozzle diameter $D_N$ (mm)</label>
            <input id="dn" type="number" value="26" step="0.01" style="width:140px" />
          </div>
          <div>
            <label>Swirler inlet diameter $D_1$ (mm)</label>
            <input id="d1" type="number" value="65" step="0.01" style="width:140px" />
          </div>
        </div>

        <div class="input-group">
          <div>
            <label>Number of tangential inlets</label>
            <input id="nInlets" type="number" value="4" min="1" step="1" style="width:140px" />
          </div>
          <div>
            <label>Inlet height (h) and width (b) (mm)</label>
            <div class="dual-input" style="margin-top:8px">
              <input id="h" type="number" value="10" step="0.01" />
              <input id="b" type="number" value="5.276" step="0.001" />
            </div>
          </div>
        </div>
      </div>

      <div class="controls" style="margin-top:18px;">
        <button id="compute" class="btn">Compute (from manual values)</button>
        <a id="shareLink" class="link" href="#" title="Copies the shareable URL">📋 Shareable link</a>
      </div>

      <hr />

      <div class="math-notes" style="margin-top:18px;">
        <h3>Target-driven calculations</h3>
        <div class="analysis-grid">
          <div class="analysis-section">
            <div class="section-header">
              <span class="section-number">A</span>
              <h4>Target Reynolds → compute $Q_{ax}$</h4>
            </div>
            <p>Enter a target Reynolds (using nozzle diameter and mean axial velocity). This will compute the axial flowrate (GPM) required to reach that Re, keeping geometry fixed.</p>
            <div style="display:grid; gap:8px; margin-top:8px;">
              <input id="targetRe" type="number" placeholder="e.g. 20000" step="1" />
              <div style="display:flex; gap:8px;">
                <button id="applyRe" class="btn">Compute Q<sub>ax</sub> for target Re</button>
                <button id="previewRe" class="btn green">Preview (sets slider)</button>
              </div>
              <div id="reResult" class="small" style="color:var(--text-secondary)"></div>
            </div>
          </div>

          <div class="analysis-section highlight">
            <div class="section-header">
              <span class="section-number">B</span>
              <h4>Target Swirl (S)</h4>
            </div>
            <p>Enter a target S and choose whether to solve for Q<sub>tan</sub> (given Q<sub>ax</sub>) or Q<sub>ax</sub> (given Q<sub>tan</sub>).</p>
            <div style="display:grid; gap:8px; margin-top:8px;">
              <input id="targetS" type="number" placeholder="e.g. 0.8" step="0.001" />
              <label style="font-size:13px; font-weight:600; margin-top:6px;">Solve for</label>
              <select id="solveForS" style="padding:10px; border-radius:8px; border:2px solid var(--border);">
                <option value="qtan">Q<sub>tan</sub> (given Q<sub>ax</sub>)</option>
                <option value="qax">Q<sub>ax</sub> (given Q<sub>tan</sub>)</option>
              </select>
              <div style="display:flex; gap:8px;">
                <button id="applyS" class="btn">Compute</button>
                <button id="previewS" class="btn green">Preview (sets slider)</button>
              </div>
              <div id="sResult" class="small" style="color:var(--text-secondary)"></div>
            </div>
          </div>
        </div>
      </div>

<div class="muted-note" style="margin-top:20px">
  <strong>Notes:</strong> The swirl number is computed from the tangential inlet flow, assuming the tangential (azimuthal) velocity at the inlet is 
  \( v_{2,\theta} = \dfrac{Q_{tan}}{A_2} \), and conservation of angular momentum scales it to the nozzle:
  \( v_{N,\theta} = v_{2,\theta}\,\dfrac{D_1}{D_N} \).  
  The axial velocity at the nozzle is \( v_{N,ax} = \dfrac{Q_{ax}}{A_N} \).  
  Geometry inputs are in <strong>mm</strong>.  
  Reference data: (at 301K ~ 28C)
  <a href="https://www.engineeringtoolbox.com/water-dynamic-kinematic-viscosity-d_596.html" target="_blank">
    Water viscosity – Engineering Toolbox,
  <a href="https://www.engineeringtoolbox.com/water-density-specific-weight-d_595.html" target="_blank">
    Water density – Engineering Toolbox
  </a>
</div>


      <hr />

      <div class="math-notes" id="latexNotes">
        <h3>Equations Behind the Parameter Calculator</h3>
        <p style="margin-bottom:24px; color:var(--text-secondary); font-size:15px;">Mathematical foundation for swirl and Reynolds number calculations</p>

        <div class="analysis-grid">
          <div class="analysis-section">
            <div class="section-header">
              <span class="section-number">1</span>
              <h4>Flowrate Relations</h4>
            </div>
            <p>Let the total volumetric flowrate be $Q$, composed of axial and tangential portions:</p>
            <div class="eq">\[ Q = Q_{ax} + Q_{tan} \]</div>
            <p>At the nozzle section:</p>
            <div class="eq">\[ Q_{ax} = A_N \, \bar{v}_{N,ax} \]</div>
            <p>At the tangential swirler inlets:</p>
            <div class="eq">\[ Q_{tan} = A_2 \, \bar{v}_{2,ax} \]</div>
          </div>

          <div class="analysis-section">
            <div class="section-header">
              <span class="section-number">2</span>
              <h4>Nozzle Geometry</h4>
            </div>
            <p>For a circular nozzle of diameter \(D_N\):</p>
            <div class="eq">\[ A_N = \dfrac{\pi}{4} D_N^2 \]</div>
          </div>

          <div class="analysis-section highlight">
            <div class="section-header">
              <span class="section-number">3</span>
              <h4>Reynolds Number</h4>
            </div>
            <p>The nozzle Reynolds number (using nozzle diameter and mean velocity):</p>
            <div class="eq key-eq">\[\boxed{\mathrm{Re} = \dfrac{\rho\,D_N\,\bar{v}_N}{\mu}}\]</div>
            <p>where \(\rho\) is density, \(\mu\) is dynamic viscosity, and \(\bar{v}_N\) is the characteristic mean velocity at the nozzle.</p>
          </div>

          <div class="analysis-section">
            <div class="section-header">
              <span class="section-number">4</span>
              <h4>Swirler Cross-Section</h4>
            </div>
            <p>If each tangential inlet has rectangular cross-section \(b \times h\) and there are \(n\) inlets:</p>
            <div class="eq">\[ A_2 = n(bh) \]</div>
            <div class="eq">\[ \bar{v}_2 = \dfrac{Q_{tan}}{A_2} \]</div>
          </div>

          <div class="analysis-section">
            <div class="section-header">
              <span class="section-number">5</span>
              <h4>Angular Momentum Balance</h4>
            </div>
            <p>Specific angular momentum (per unit mass) at radius \(r\):</p>
            <div class="eq">\[ L = r\,v_{\theta} \]</div>
            <p>At the swirler inlet (diameter \(D_1\)) and at the nozzle exit (diameter \(D_N\)):</p>
            <div class="eq">\[ L_2 = \dfrac{D_1}{2}\bar{v}_{2,\theta} \qquad L_N = \dfrac{D_N}{2}\bar{v}_{N,\theta} \]</div>
            <p>Assuming steady, axisymmetric flow with negligible losses, conservation of angular momentum yields:</p>
            <div class="eq">\[\boxed{\dfrac{D_1}{2}\,\bar{v}_{2,\theta} = \dfrac{D_N}{2}\,\bar{v}_{N,\theta}}\]</div>
            <p>Hence:</p>
            <div class="eq">\[\boxed{\bar{v}_{N,\theta} = \bar{v}_{2,\theta}\dfrac{D_1}{D_N}}\]</div>
          </div>

          <div class="analysis-section highlight">
            <div class="section-header">
              <span class="section-number">6</span>
              <h4>Swirl Number Definition</h4>
            </div>
            <p>The swirl number at the nozzle is the ratio of azimuthal to axial mean velocities:</p>
            <div class="eq key-eq">\[\boxed{S = \dfrac{\bar{v}_{N,\theta}}{\bar{v}_{N,ax}}}\]</div>
            <p style="margin-top:12px; padding:12px; background:#fef3c7; border-left:3px solid #f59e0b; border-radius:6px; font-size:13px;">
              <strong>Key Insight:</strong> The swirl number quantifies the strength of rotation relative to axial flow. Higher values indicate stronger swirling motion.
            </p>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>

// --- Global variables ---
const RHO = 996.3;   // kg/m^3
const MU  = 8.345e-4; // Pa·s  (N·s/m²) //james
const axial=document.getElementById('axial'), tang=document.getElementById('tangential');
const axialVal=document.getElementById('axialVal'), tanVal=document.getElementById('tanVal');
const Sdisp=document.getElementById('S'), Redisp=document.getElementById('Re'), QtotDisp=document.getElementById('Qtot');
const qaxEl=document.getElementById('qax'), qtanEl=document.getElementById('qtan');
const dnEl=document.getElementById('dn'), d1El=document.getElementById('d1');
const nInletsEl=document.getElementById('nInlets'), hEl=document.getElementById('h'), bEl=document.getElementById('b');
const computeBtn=document.getElementById('compute'), shareLink=document.getElementById('shareLink');

const targetReEl = document.getElementById('targetRe'), applyReBtn = document.getElementById('applyRe'), previewReBtn = document.getElementById('previewRe'), reResult = document.getElementById('reResult');
const targetSEl = document.getElementById('targetS'), solveForS = document.getElementById('solveForS'), applySBtn = document.getElementById('applyS'), previewSBtn = document.getElementById('previewS'), sResult = document.getElementById('sResult');

const ctx=document.getElementById('barChart').getContext('2d');
const barChart=new Chart(ctx,{
  type:'bar',
  data:{
    labels:['Axial (GPM)','Tangential (GPM)'],
    datasets:[{
      data:[Number(axial.value),Number(tang.value)],
      backgroundColor:['#3b82f6','#f97316'],
      borderRadius: 8,
      borderSkipped: false,
    }]
  },
  options:{
    responsive:true,
    maintainAspectRatio:false,
    scales:{
      y:{
        beginAtZero:true,
        grid: {
          color: '#e2e8f0'
        }
      },
      x: {
        grid: {
          display: false
        }
      }
    },
    plugins:{
      legend:{display:false}
    }
  }
});

const GPM_TO_M3S=6.30902e-5, MM_TO_M=0.001;

function computeFromValues(qAxGpm,qTanGpm,dN_mm=26,d1_mm=65,nInlets=4,h_mm=10,b_mm=5.276){
 const qAx=+qAxGpm,qTan=+qTanGpm,qTotGpm=qAx+qTan;
 const dN_m=dN_mm*MM_TO_M,d1_m=d1_mm*MM_TO_M;
 const h_m=h_mm*MM_TO_M,b_m=b_mm*MM_TO_M;
 const A_n=Math.PI*Math.pow(dN_m/2,2), A2=Math.max(0,nInlets*(b_m*h_m));
 const Qax_m3s=qAx*GPM_TO_M3S, Qtan_m3s=qTan*GPM_TO_M3S;
 const vN_ax=A_n?Qax_m3s/A_n:0, v2_theta=A2?Qtan_m3s/A2:0, vN_theta=dN_m?v2_theta*(d1_m/dN_m):0;
 let S; if(vN_ax===0&&vN_theta===0)S=0; else if(vN_ax===0)S=Infinity; else S=vN_theta/vN_ax;
 const Re=A_n?RHO*vN_ax*dN_m/MU:0;
 return {qAx,qTan,qTotGpm,vN_ax,v2_theta,vN_theta,S,Re,A_n,A2,dN_m,d1_m};
}

// --- Inverse calculations ---

// Given target Re and geometry, compute Qax (GPM) required.
function computeQaxForRe(targetRe, dN_mm, A_n){
  const dN_m = dN_mm*MM_TO_M;
  if (!A_n || dN_m <= 0) return {error: 'invalid geometry (A_n or D_N)'} ;
  // Re = rho * Dn * vN_ax / mu
  // vN_ax = Re * mu / (rho * Dn)
  // Qax_m3s = vN_ax * A_n
  const vN_ax = targetRe * MU / (RHO * dN_m);
  const Qax_m3s = vN_ax * A_n;
  const Qax_gpm = Qax_m3s / GPM_TO_M3S;
  return {Qax_gpm, vN_ax, Qax_m3s};
}

// Given target S and geometry + Qax, compute Qtan (GPM)
function computeQtanForS(targetS, qAx_gpm, A_n, A2, dN_m, d1_m){
  // S = ( (Qtan/A2)*(d1/dN) ) / (Qax/A_n)
  // => Qtan = S * Qax * A2 * dN / (A_n * d1)
  if (!A2 || !A_n || d1_m<=0 || dN_m<=0) return {error:'invalid geometry (A2/A_n/D)'} ;
  const Qax_m3s = qAx_gpm * GPM_TO_M3S;
  const Qtan_m3s = targetS * Qax_m3s * A2 * dN_m / (A_n * d1_m);
  const Qtan_gpm = Qtan_m3s / GPM_TO_M3S;
  return {Qtan_gpm, Qtan_m3s};
}

// Given target S and geometry + Qtan, compute Qax (GPM)
function computeQaxForS(targetS, qTan_gpm, A_n, A2, dN_m, d1_m){
  // S = ( (Qtan/A2)*(d1/dN) ) / (Qax/A_n)
  // => Qax = Qtan * A_n * d1 / (S * A2 * dN)
  if (!A2 || !A_n || d1_m<=0 || dN_m<=0 || targetS===0) return {error:'invalid geometry or S'} ;
  const Qtan_m3s = qTan_gpm * GPM_TO_M3S;
  const Qax_m3s = Qtan_m3s * A_n * d1_m / (targetS * A2 * dN_m);
  const Qax_gpm = Qax_m3s / GPM_TO_M3S;
  return {Qax_gpm, Qax_m3s};
}

// UI helpers
const safeNumber = (v, digits = 3) => (Number.isFinite(v) ? Number(v).toFixed(digits) : (v === Infinity ? '∞' : '—'));
const safeInt = v => (Number.isFinite(v) ? Math.round(v).toLocaleString() : v === Infinity ? '∞' : '—');

function updateCalculatorUI(){
 const qAx=+axial.value,qTan=+tang.value;
 axialVal.textContent=qAx.toFixed(2); tanVal.textContent=qTan.toFixed(2);
 const dn_mm=Number(dnEl.value)||26, d1_mm=Number(d1El.value)||65;
 const nInlets=Number(nInletsEl.value)||4, h_mm=Number(hEl.value)||10, b_mm=Number(bEl.value)||5.276;
 const out=computeFromValues(qAx,qTan,dn_mm,d1_mm,nInlets,h_mm,b_mm);
 Sdisp.textContent=isFinite(out.S)?out.S.toFixed(3):'∞';
 QtotDisp.textContent=out.qTotGpm.toFixed(2)+' GPM';
 Redisp.textContent=Math.round(out.Re).toLocaleString();
 barChart.data.datasets[0].data=[qAx,qTan]; barChart.update();
 qaxEl.value=qAx; qtanEl.value=qTan;
 const url=new URL(location.href.split('#')[0]);
 url.searchParams.set('qax', qAx); url.searchParams.set('qtan', qTan);
 url.searchParams.set('dn_mm', dn_mm); url.searchParams.set('d1_mm', d1_mm);
 url.searchParams.set('n', nInlets); url.searchParams.set('h_mm', h_mm); url.searchParams.set('b_mm', b_mm);
 shareLink.href = url.toString();
}

axial.addEventListener('input', updateCalculatorUI);
tang.addEventListener('input', updateCalculatorUI);

// sync manual inputs to sliders when user clicks compute
computeBtn.addEventListener('click', () => {
  const qAx = Number(qaxEl.value) || 0;
  const qTan = Number(qtanEl.value) || 0;
  const dn_mm = Number(dnEl.value) || 26;
  const d1_mm = Number(d1El.value) || 65;
  const nInlets = Number(nInletsEl.value) || 4;
  const h_mm = Number(hEl.value) || 10;
  const b_mm = Number(bEl.value) || 5.276;

  // set sliders -> update UI
  axial.value = qAx;
  tang.value = qTan;

  updateCalculatorUI();

  // update share link
  const url = new URL(location.href.split('#')[0]);
  url.searchParams.set('qax', qAx); url.searchParams.set('qtan', qTan);
  url.searchParams.set('dn_mm', dn_mm); url.searchParams.set('d1_mm', d1_mm);
  url.searchParams.set('n', nInlets); url.searchParams.set('h_mm', h_mm); url.searchParams.set('b_mm', b_mm);
  shareLink.href = url.toString();
  
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
});

// initialize
(function init(){
 axial.value=18; tang.value=8;
 dnEl.value=26; d1El.value=65; nInletsEl.value=4; hEl.value=10; bEl.value=5.276;
 qaxEl.value=Number(axial.value); qtanEl.value=Number(tang.value);
 updateCalculatorUI();
})();

// --- Target Re handlers ---
applyReBtn.addEventListener('click', () => {
  const targetRe = Number(targetReEl.value);
  const dn_mm = Number(dnEl.value) || 26;
  // compute geometry A_n using current dn
  const dN_m = dn_mm*MM_TO_M;
  const A_n = Math.PI*Math.pow(dN_m/2,2);
  if (!Number.isFinite(targetRe) || targetRe <= 0) {
    reResult.textContent = 'Please enter a positive target Re.';
    return;
  }
  const result = computeQaxForRe(targetRe, dn_mm, A_n);
  if (result.error) {
    reResult.textContent = 'Error: ' + result.error;
    return;
  }
  // apply: set axial slider and manual input to the computed Qax
  const Qax_gpm = result.Qax_gpm;
  axial.value = Math.max(0, Qax_gpm);
  qaxEl.value = Number(Qax_gpm.toFixed(3));
  updateCalculatorUI();
  reResult.textContent = `Computed Q_ax = ${Number(Qax_gpm.toFixed(4))} GPM (to reach Re=${targetRe}).`;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
});

previewReBtn.addEventListener('click', () => {
  const targetRe = Number(targetReEl.value);
  const dn_mm = Number(dnEl.value) || 26;
  const dN_m = dn_mm*MM_TO_M;
  const A_n = Math.PI*Math.pow(dN_m/2,2);
  if (!Number.isFinite(targetRe) || targetRe <= 0) {
    reResult.textContent = 'Please enter a positive target Re.';
    return;
  }
  const result = computeQaxForRe(targetRe, dn_mm, A_n);
  if (result.error) {
    reResult.textContent = 'Error: ' + result.error;
    return;
  }
  reResult.textContent = `Preview Q_ax = ${Number(result.Qax_gpm.toFixed(4))} GPM (slider will be updated if you "Compute").`;
});

// --- Target S handlers ---
applySBtn.addEventListener('click', () => {
  const targetS = Number(targetSEl.value);
  const dn_mm = Number(dnEl.value) || 26, d1_mm = Number(d1El.value) || 65;
  const nInlets = Number(nInletsEl.value) || 4, h_mm = Number(hEl.value) || 10, b_mm = Number(bEl.value) || 5.276;
  const dN_m = dn_mm*MM_TO_M, d1_m = d1_mm*MM_TO_M;
  const A_n = Math.PI*Math.pow(dN_m/2,2);
  const A2 = Math.max(0, nInlets*(h_mm*MM_TO_M)*(b_mm*MM_TO_M));

  if (!Number.isFinite(targetS) || targetS < 0) {
    sResult.textContent = 'Please enter a non-negative target S.';
    return;
  }

  const mode = solveForS.value; // 'qtan' or 'qax'
  if (mode === 'qtan') {
    const qAx = Number(qaxEl.value) || Number(axial.value) || 0;
    const res = computeQtanForS(targetS, qAx, A_n, A2, dN_m, d1_m);
    if (res.error) { sResult.textContent = 'Error: '+res.error; return; }
    const Qtan_gpm = res.Qtan_gpm;
    // apply to UI
    tang.value = Math.max(0, Qtan_gpm);
    qtanEl.value = Number(Qtan_gpm.toFixed(4));
    updateCalculatorUI();
    sResult.textContent = `Computed Q_tan = ${Number(Qtan_gpm.toFixed(4))} GPM for S=${targetS} (given Q_ax=${qAx} GPM).`;
  } else {
    // compute Qax given qtan
    const qTan = Number(qtanEl.value) || Number(tang.value) || 0;
    if (targetS === 0) {
      sResult.textContent = 'Target S cannot be zero when solving for Q_ax (division by zero).';
      return;
    }
    const res = computeQaxForS(targetS, qTan, A_n, A2, dN_m, d1_m);
    if (res.error) { sResult.textContent = 'Error: '+res.error; return; }
    const Qax_gpm = res.Qax_gpm;
    axial.value = Math.max(0, Qax_gpm);
    qaxEl.value = Number(Qax_gpm.toFixed(4));
    updateCalculatorUI();
    sResult.textContent = `Computed Q_ax = ${Number(Qax_gpm.toFixed(4))} GPM for S=${targetS} (given Q_tan=${qTan} GPM).`;
  }

  // update share link
  const url = new URL(location.href.split('#')[0]);
  url.searchParams.set('qax', axial.value); url.searchParams.set('qtan', tang.value);
  url.searchParams.set('dn_mm', dn_mm); url.searchParams.set('d1_mm', d1_mm);
  url.searchParams.set('n', nInlets); url.searchParams.set('h_mm', h_mm); url.searchParams.set('b_mm', b_mm);
  shareLink.href = url.toString();

  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
});

previewSBtn.addEventListener('click', () => {
  const targetS = Number(targetSEl.value);
  const dn_mm = Number(dnEl.value) || 26, d1_mm = Number(d1El.value) || 65;
  const nInlets = Number(nInletsEl.value) || 4, h_mm = Number(hEl.value) || 10, b_mm = Number(bEl.value) || 5.276;
  const dN_m = dn_mm*MM_TO_M, d1_m = d1_mm*MM_TO_M;
  const A_n = Math.PI*Math.pow(dN_m/2,2);
  const A2 = Math.max(0, nInlets*(h_mm*MM_TO_M)*(b_mm*MM_TO_M));

  if (!Number.isFinite(targetS) || targetS < 0) {
    sResult.textContent = 'Please enter a non-negative target S.';
    return;
  }

  const mode = solveForS.value;
  if (mode === 'qtan') {
    const qAx = Number(qaxEl.value) || Number(axial.value) || 0;
    const res = computeQtanForS(targetS, qAx, A_n, A2, dN_m, d1_m);
    if (res.error) { sResult.textContent = 'Error: '+res.error; return; }
    sResult.textContent = `Preview Q_tan = ${Number(res.Qtan_gpm.toFixed(4))} GPM for S=${targetS} (given Q_ax=${qAx} GPM).`;
  } else {
    const qTan = Number(qtanEl.value) || Number(tang.value) || 0;
    if (targetS === 0) { sResult.textContent = 'Target S cannot be zero when previewing Q_ax.'; return; }
    const res = computeQaxForS(targetS, qTan, A_n, A2, dN_m, d1_m);
    if (res.error) { sResult.textContent = 'Error: '+res.error; return; }
    sResult.textContent = `Preview Q_ax = ${Number(res.Qax_gpm.toFixed(4))} GPM for S=${targetS} (given Q_tan=${qTan} GPM).`;
  }
});

</script>
</body>
</html>